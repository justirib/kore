<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Subway Surf: Solid Physics</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Verdana', sans-serif; }
        #ui { position: absolute; top: 20px; left: 20px; color: white; font-weight: bold; text-shadow: 2px 2px 0 #000; font-size: 24px; pointer-events: none; }
        #msg { position: absolute; top: 50%; width: 100%; text-align: center; color: red; font-size: 40px; display: none; text-shadow: 2px 2px 0 #fff; font-weight: 900; }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="ui">SCORE: <span id="score">0</span></div>
    <div id="msg">CRASHED!</div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- Configuration ---
        const LANE_WIDTH = 4;
        const PLAYER_HEIGHT = 1.5;
        const TRAIN_WIDTH = 3.2;
        const TRAIN_HEIGHT = 3.5;
        const TRAIN_LENGTH = 20;
        
        // --- State ---
        let gameActive = true;
        let score = 0;
        let speed = 0.6;
        let lane = 0; // -1, 0, 1
        let vY = 0;
        let gravity = 0.025;
        let playerY = 0; // The visual Y position offset
        let isJumping = false;
        let onTrain = false; // Are we currently running on a roof?

        // --- Setup Scene ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, 120);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);
        camera.position.set(0, 7, 12);
        camera.lookAt(0, 2, -10);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- Lighting ---
        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);
        const sun = new THREE.DirectionalLight(0xffffff, 1.5);
        sun.position.set(20, 50, 20);
        sun.castShadow = true;
        sun.shadow.camera.bottom = -50;
        sun.shadow.camera.left = -50;
        sun.shadow.camera.right = 50;
        sun.shadow.camera.top = 50;
        scene.add(sun);

        // --- Textures (Procedural) ---
        function createTexture(color, type) {
            const cvs = document.createElement('canvas');
            cvs.width = 128; cvs.height = 128;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle = color;
            ctx.fillRect(0,0,128,128);
            
            // Add grunge/details
            ctx.fillStyle = "rgba(0,0,0,0.2)";
            if(type === 'grid') {
                ctx.fillRect(0, 0, 128, 10);
                ctx.fillRect(0, 0, 10, 128);
            } else if (type === 'noise') {
                for(let i=0; i<100; i++) ctx.fillRect(Math.random()*128, Math.random()*128, 4, 4);
            }
            
            return new THREE.CanvasTexture(cvs);
        }

        const matTrain = new THREE.MeshStandardMaterial({ map: createTexture('#d63031', 'noise'), roughness: 0.2 });
        const matRamp = new THREE.MeshStandardMaterial({ map: createTexture('#fdcb6e', 'grid') });
        const matFloor = new THREE.MeshStandardMaterial({ map: createTexture('#2d3436', 'noise'), roughness: 0.8 });
        const matPlayer = new THREE.MeshStandardMaterial({ color: 0x0984e3 });

        // --- Objects ---
        
        // Floor
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(30, 1000), matFloor);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Player (Composite Geometry)
        const playerGroup = new THREE.Group();
        const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.5, 1, 4, 8), matPlayer);
        body.position.y = 1;
        body.castShadow = true;
        playerGroup.add(body);
        scene.add(playerGroup);

        // Chaser
        const chaser = new THREE.Mesh(new THREE.CapsuleGeometry(0.6, 1.2, 4, 8), new THREE.MeshStandardMaterial({ color: 0x222222 }));
        chaser.position.set(0, 1, 5);
        scene.add(chaser);

        // Obstacle Arrays
        let trains = [];
        let ramps = [];

        // --- Spawning Logic ---
        function spawnTrain(zPos, laneIdx) {
            const group = new THREE.Group();
            
            // Solid Box for collision logic
            const geo = new THREE.BoxGeometry(TRAIN_WIDTH, TRAIN_HEIGHT, TRAIN_LENGTH);
            const mesh = new THREE.Mesh(geo, matTrain);
            mesh.position.y = TRAIN_HEIGHT / 2;
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            // Add details (Wheels) to make it look cool
            const wheelGeo = new THREE.CylinderGeometry(0.5, 0.5, 3.3);
            const wheelMat = new THREE.MeshStandardMaterial({color:0x111111});
            const w1 = new THREE.Mesh(wheelGeo, wheelMat); w1.rotation.z = Math.PI/2; w1.position.set(0, 0.5, 5);
            const w2 = new THREE.Mesh(wheelGeo, wheelMat); w2.rotation.z = Math.PI/2; w2.position.set(0, 0.5, -5);
            
            group.add(mesh, w1, w2);
            group.position.set(laneIdx * LANE_WIDTH, 0, zPos);
            
            // Store Metadata for physics
            group.userData = { 
                type: 'train', 
                width: TRAIN_WIDTH, 
                height: TRAIN_HEIGHT, 
                length: TRAIN_LENGTH 
            };
            
            scene.add(group);
            trains.push(group);
        }

        function spawnRamp(zPos, laneIdx) {
            const shape = new THREE.Shape();
            shape.moveTo(-1.5, 0);
            shape.lineTo(1.5, 0);
            shape.lineTo(1.5, TRAIN_HEIGHT); // Ramp goes up to train height
            shape.lineTo(-1.5, TRAIN_HEIGHT);
            shape.lineTo(-1.5, 0);

            const extrudeSettings = { steps: 1, depth: 8, bevelEnabled: false };
            const geo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            const mesh = new THREE.Mesh(geo, matRamp);
            
            mesh.position.set(laneIdx * LANE_WIDTH, 0, zPos); // Start of ramp
            mesh.rotation.x = Math.PI; // Flip it to slope Up
            // Extrude creates it backwards on Z, so we adjust rotation
            mesh.rotation.y = Math.PI; 
            
            mesh.userData = { type: 'ramp', height: TRAIN_HEIGHT };
            scene.add(mesh);
            ramps.push(mesh);
        }

        // --- Input ---
        const handleInput = (key) => {
            if (!gameActive) return;
            if (key === 'Left' && lane > -1) lane--;
            if (key === 'Right' && lane < 1) lane++;
            if (key === 'Up' && !isJumping) {
                vY = 0.5; // Jump force
                isJumping = true;
            }
        };

        window.addEventListener('keydown', e => {
            if(e.key === 'ArrowLeft') handleInput('Left');
            if(e.key === 'ArrowRight') handleInput('Right');
            if(e.key === ' ' || e.key === 'ArrowUp') handleInput('Up');
        });

        let touchStart = 0;
        window.addEventListener('touchstart', e => touchStart = e.touches[0].clientX);
        window.addEventListener('touchend', e => {
            const diff = e.changedTouches[0].clientX - touchStart;
            if(Math.abs(diff) > 30) handleInput(diff > 0 ? 'Right' : 'Left');
            else handleInput('Up');
        });

        // --- Physics Engine ---
        function updatePhysics() {
            // Move Player X (Lane switching)
            playerGroup.position.x = THREE.MathUtils.lerp(playerGroup.position.x, lane * LANE_WIDTH, 0.2);

            // 1. Determine "Ground Level" for the player
            // By default, ground is 0. If we are above a train, ground is TRAIN_HEIGHT.
            let groundLevel = 0;
            let aboveSolid = false;

            // Check Trains
            trains.forEach(t => {
                // Collision Bounds (Simple AABB)
                const dx = Math.abs(t.position.x - playerGroup.position.x);
                const dz = t.position.z - playerGroup.position.z; // Positive means train is in front (or under)
                
                // Are we physically "inside" the train's footprint?
                // Train Z center is t.position.z. Length is 20. Bounds are [z-10, z+10].
                // Player Z is 0 (relative to moving world, effectively).
                
                // Wait! In this engine, objects move towards player. Player Z is roughly static 0.
                // Actually, let's keep player Z at 0 and move objects.
                const zDist = t.position.z; // Distance from player (0)
                const isOverlappingZ = zDist > -10 && zDist < 10; // Within length
                const isOverlappingX = dx < 2.0; // Within width

                if (isOverlappingZ && isOverlappingX) {
                    // We are intersecting the train's footprint.
                    
                    // Case A: We are HIGH enough to be on top
                    // Allow a small buffer (0.5) so you don't clip toes
                    if (playerGroup.position.y >= TRAIN_HEIGHT - 0.5) {
                        groundLevel = TRAIN_HEIGHT;
                        aboveSolid = true;
                    } 
                    // Case B: We hit the FRONT or SIDE (Crash)
                    else {
                        // Only crash if we are actually touching it physically
                        if (zDist < 9 && zDist > -9) { 
                             gameOver();
                        }
                    }
                }
            });

            // Check Ramps (Ramps just lift you up smoothly)
            ramps.forEach(r => {
                // Ramps are positioned at their TOP Z. They extend 8 units back.
                // Adjust for rotation: mesh is at Z, extends to Z-8.
                const zDist = r.position.z; 
                const dx = Math.abs(r.position.x - playerGroup.position.x);
                
                if (dx < 2.0 && zDist > 0 && zDist < 8) {
                    // Simple linear interpolation for ramp height
                    // 0 at Z=8, Max at Z=0.
                    const percent = (8 - zDist) / 8; // 0 to 1
                    const rampHeight = percent * TRAIN_HEIGHT;
                    if (rampHeight > groundLevel) groundLevel = rampHeight;
                }
            });

            // 2. Apply Gravity / Snap to Ground
            if (playerGroup.position.y > groundLevel) {
                // Falling
                playerGroup.position.y += vY;
                vY -= gravity;
            } 
            
            // 3. Ground Collision
            if (playerGroup.position.y <= groundLevel) {
                playerGroup.position.y = groundLevel;
                vY = 0;
                isJumping = false;
            }
        }

        function gameOver() {
            gameActive = false;
            document.getElementById('msg').style.display = 'block';
            speed = 0;
        }

        // --- Game Loop ---
        let frame = 0;
        function animate() {
            if(!gameActive) return;
            requestAnimationFrame(animate);
            frame++;

            // Spawn Logic
            if (frame % 60 === 0) {
                const r = Math.random();
                // Random Lane
                const l = Math.floor(Math.random() * 3) - 1; 

                if (r < 0.3) {
                    // Spawn Ramp + Train combo
                    spawnRamp(-100, l);
                    spawnTrain(-108 - (TRAIN_LENGTH/2), l); 
                } else if (r < 0.6) {
                    // Just a Train (Jumpable or dodgeable)
                    spawnTrain(-100, l);
                }
            }

            // Move World (Illusion of speed)
            const moveObj = (arr) => {
                for (let i = arr.length - 1; i >= 0; i--) {
                    arr[i].position.z += speed;
                    if (arr[i].position.z > 20) {
                        scene.remove(arr[i]);
                        arr.splice(i, 1);
                        score++;
                    }
                }
            };
            moveObj(trains);
            moveObj(ramps);

            // Update Physics
            updatePhysics();

            // Chaser Logic
            chaser.position.x = THREE.MathUtils.lerp(chaser.position.x, playerGroup.position.x, 0.05);
            chaser.position.y = playerGroup.position.y; // Chaser jumps with you

            document.getElementById('score').innerText = Math.floor(score/10);
            renderer.render(scene, camera);
        }

        // Adjust for resizing
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });

        animate();

    </script>
</body>
</html>
